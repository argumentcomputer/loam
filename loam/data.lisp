(declaim (optimize safety))

;; TODO:
;; - err

(in-package #:data)
(def-suite* data-suite :in loam:master-suite)

;; '(:nil :cons :sym :fun :num :str :char :comm :u64 :key :env :err :thunk :builtin :bignum)
(deflexical +tags+ (allocation-tag-names (make-instance 'lurk-allocation)))

(let ((builtin-package (find-package :lurk.builtin)))
  (defun* lurk-builtin-p ((s symbol))
    (eq (symbol-package s) builtin-package)))

;; bignum is reserved.
(deftype wide-num () '(unsigned-byte 256))

(defstruct (num (:constructor num (value)))
  (value 0 :type element))

(defstruct (comm (:constructor comm (secret value))) secret value)

(deftype maybe-env () '(or null env))
(defstruct (env (:constructor env (key value next-env)))
  (key nil :type symbol)
  (value nil :type t)
  (next-env nil :type maybe-env))

(defstruct (thunk (:constructor thunk (body closed-env))) body (closed-env maybe-env))
(defstruct (fun (:constructor fun (args body closed-env)))
  (args nil :type list)
  (body nil :type t)
  (closed-env maybe-env))

(defun tag (thing)
  (etypecase thing
    (null :nil)
    (cons :cons)
    (keyword :key)
    (symbol (if (lurk-builtin-p thing) :builtin :sym))
    (num :num)
    ((unsigned-byte 64) :u64)
    (wide-num :bignum)
    (function :fun)
    (string :str)
    (character :char)
    (comm :comm)
    (thunk :thunk)
    (env :env)
    (fun :fun)))

;; size is number of elements, bits is bits per 'element'
(defun le-elements<- (x &key size (bits 8))
  (assert (<= bits +element-bits+))
  (let ((bytes (loop for i from 0
                     for n = x then (ash n (- bits))
                     while (or (> n 0) (and size (< i size)))
                     collect (ldb (byte bits 0) n))))
    (when size
      (assert (<= (length bytes) size)))
    ;; TODO: optimize. This implementation is just to figure out types.
    (make-array (length bytes) :initial-contents bytes :element-type 'element)))

(defun symbol-path (symbol)
  ;; All CL symbols have path of length 2 without hierarchical symbols.
  (list (symbol-name symbol) (package-name (symbol-package symbol))))

(defgeneric value<-expr (tag expr)
  (:method ((tag (eql :nil)) x)
    (assert (null x))
    (value<-expr :sym nil))
  (:method ((tag (eql :cons)) (x cons))
    (let ((car (intern-wide-ptr (car x)))
          (cdr (intern-wide-ptr (cdr x))))
      (hash (wide-ptr-tag car) (wide-ptr-value car) (wide-ptr-tag cdr) (wide-ptr-value cdr))))
  (:method ((tag (eql :comm)) (x comm))
    (let ((secret (value<-expr :bignum (comm-secret x)))
          (value (intern-wide-ptr (comm-value x))))
      (hash secret (wide-ptr-tag value) (wide-ptr-value value))))
  (:method ((tag (eql :sym)) (s symbol))
    (let ((str-tag-value (tag-value :str))
          (sym-tag-value (tag-value :sym)))
      (reduce (lambda (acc s)
                (hash str-tag-value (value<-expr :str s) sym-tag-value acc))
              (reverse (symbol-path s))
              :initial-value (widen 0))))
  (:method ((tag (eql :builtin)) (s symbol))
    (value<-expr :sym s))
  (:method ((tag (eql :key)) (s symbol))
    (value<-expr :sym s))
  (:method ((tag (eql :num)) (x num))
    (widen (num-value x)))
  (:method ((tag (eql :str)) (s string))
    (reduce (lambda (acc c)
              (hash (tag-value :char) (value<-expr :char c) (tag-value :str) acc))
            (reverse s)
            :initial-value (widen 0)))
  (:method ((tag (eql :char)) (c character))
    (make-wide :elements (le-elements<- (char-code c) :size 8)))
  (:method ((tag (eql :u64)) x)
    (make-wide :elements (le-elements<- x :size 8)))
  (:method ((tag (eql :bignum)) x)
    (make-wide :elements (le-elements<- x :size 8 :bits +element-bits+)))
  (:method ((tag (eql :env)) x)
    (let ((env-value (intern-wide-ptr (env-value x))))
      (hash (value<-expr :sym (env-key x)) (wide-ptr-tag env-value)
            (wide-ptr-value env-value) (etypecase (env-next-env x)
                                         (env (wide-ptr-value (intern-wide-ptr (env-next-env x))))
                                         (null (widen 0))))))
  (:method ((tag (eql :thunk)) x)
    (let ((body (intern-wide-ptr (thunk-body x)))
          (closed-env (intern-wide-ptr (thunk-closed-env x))))
    (hash (wide-ptr-tag body) (wide-ptr-value body)
          (wide-ptr-tag closed-env) (wide-ptr-value closed-env))))
  (:method ((tag (eql :fun)) x)
    (let ((args (intern-wide-ptr (fun-args x)))
          (body (intern-wide-ptr (fun-body x)))
          (closed-env (intern-wide-ptr (fun-closed-env x))))
    (hash (wide-ptr-tag args) (wide-ptr-value args)
          (wide-ptr-tag body) (wide-ptr-value body)
          (wide-ptr-tag closed-env) (wide-ptr-value closed-env)))))

(defgeneric expr<-wide (tag wide)
  (:method ((tag (eql :nil)) (w wide))
    (assert (== (value<-expr :nil nil) w)) ;; todo: this is expensive. We should also just cache original values when
                                     ;; interning. however, we need to be able to do this since we may be constructing
                                     ;; for the first time from preimages.
    nil)
  (:method ((tag (eql :num)) (w wide))
    (assert (one-non-zero-limb-p w))
    (num (wide-nth 0 w)))
  (:method ((tag (eql :char)) (w wide))
    (assert (one-non-zero-limb-p w))
    (code-char (wide-nth 0 w)))
  (:method ((tag (eql :bignum)) (w wide))
      (reduce (lambda (acc elt) (+ (ash acc +element-bits+) elt))
              (reverse (wide-elements w))
              :initial-value 0))
  (:method ((tag (eql :u64)) (w wide))
    (reduce (lambda (acc elt) (+ (ash acc 8) elt))
            (reverse (wide-elements w))
            :initial-value 0))
  (:method ((tag (eql :cons)) (w wide))
    (destructuring-bind (car-tag car-value cdr-tag cdr-value)
        (unhash w)
      (cons (expr<-wide-ptr-parts car-tag car-value)
            (expr<-wide-ptr-parts cdr-tag cdr-value))))
  (:method ((tag (eql :comm)) (w wide))
    (destructuring-bind (secret val-tag val-value)
        (unhash w 3)
        (comm (expr<-wide :bignum secret) (expr<-wide-ptr-parts val-tag val-value))))
  (:method ((tag (eql :thunk)) (w wide))
    (destructuring-bind (body-tag body-value env-tag env-value)
        (unhash w 4)
        (thunk (expr<-wide-ptr-parts body-tag body-value) 
               (expr<-wide-ptr-parts env-tag env-value))))
  (:method ((tag (eql :fun)) (w wide))
    (destructuring-bind (args-tag args-value body-tag body-value env-tag env-value)
        (unhash w 6)
        (fun (expr<-wide-ptr-parts args-tag args-value)
             (expr<-wide-ptr-parts body-tag body-value)
             (expr<-wide-ptr-parts env-tag env-value))))
  (:method ((tag (eql :env)) (w wide))
            (destructuring-bind (key-value val-tag val-value next-env)
        (unhash w 4)
      (env (expr<-wide :sym key-value)
           (expr<-wide-ptr-parts val-tag val-value)
           (unless (wide-zero-p next-env)
             (expr<-wide :env next-env)))))
  (:method ((tag (eql :str)) (w wide))
    (with-output-to-string (out)
      (loop while (not (wide-zero-p w))
            do (destructuring-bind (char-tag char-value rest-tag rest-value)
                   (unhash w)
                 (assert (== (tag-value :str) rest-tag))
                 (assert (== (tag-value :char) char-tag))
                 (let ((char (expr<-wide-ptr-parts char-tag char-value)))
                   (write-char char out)
                   (setq w rest-value))))))
  (:method ((tag (eql :sym)) (w wide))
    (let ((path (loop while (not (wide-zero-p w))
                      collect (destructuring-bind (string-tag string-value rest-tag rest-value)
                                  (unhash w)
                                (assert (== (tag-value :sym) rest-tag))
                                (assert (== (tag-value :str) string-tag))
                                (let ((name (expr<-wide-ptr-parts string-tag string-value)))
                                  (setq w rest-value)
                                  name)))))
      (assert (= 2 (length path))) ; for CL symbols, which aren't hierarchical
      (intern (car path) (find-package (cadr path)))))
  (:method ((tag (eql :key)) (w wide))
    (expr<-wide :sym w))
  (:method ((tag (eql :builtin)) (w wide))
    (expr<-wide :sym w)))

(defun wide-zero-p (wide) (every #'zerop (wide-elements wide)))
(defun one-non-zero-limb-p (wide) (every #'zerop (subseq (wide-elements wide) 1)))

(defun intern-wide-ptr (thing)
  (let* ((tag (tag thing))
         (value (value<-expr tag thing)))
    (make-wide-ptr (tag-value tag) value)))

(defun tag<-wide (wide)
  (nth-tag *program* (aref (wide-elements wide) 0)))

(defun expr<-wide-ptr-parts (wide-tag wide-value)
  (let ((tag (tag-name (tag<-wide wide-tag))))
    (expr<-wide tag wide-value)))

(defun expr<-wide-ptr (wide-ptr)
  (expr<-wide-ptr-parts (wide-ptr-tag wide-ptr) (wide-ptr-value wide-ptr)))

(defprogram test-program (hash-cache lurk-allocation)
  (relation (tag element wide)) ; (short-tag wide-tag)
  )

(test intern-wide-ptr
  (let ((*program* (make-program-instance 'test-program)))
    (is (== (make-wide-ptr (tag-value :nil)
                           (wide 3988418742 3372394342 3989293407 3622167317
                                 481098280 1226104118 3434725496 1157621715))
            (intern-wide-ptr nil)))
    (is (== (make-wide-ptr (tag-value :cons)
                           (wide 1971744287 3641459736 3774975494 1609894661
                                 2629299411 3809236520 3595245074 62596448))
            (intern-wide-ptr (cons 123 456))))
    (is (== (make-wide-ptr (tag-value :sym)
                           (wide 3397136945 3387145446 234774522 2107533973
                                 1504082815 1984471249 3548321992 3338191787))
            (intern-wide-ptr 'asparagus)))
    (is (== (make-wide-ptr (tag-value :builtin)
                           (wide 1260038541 2992399590 2762133428 3260290791
                                 4207369508 543827090 3180187974 2412760993))
            (intern-wide-ptr 'lurk:current-env)))
    (is (== (make-wide-ptr (tag-value :num) (widen 987)) (intern-wide-ptr (num 987))))
    (is (== (make-wide-ptr (tag-value :str) (widen 0)) (intern-wide-ptr "")))
    (is (== (make-wide-ptr (tag-value :str) (wide 3915542193 3963547268 1543020646 761117776
                                                  2609865840 67719049 4263057193 3398353849))
            (intern-wide-ptr "boo")))
    (is (== (make-wide-ptr (tag-value :char) (widen 65)) (intern-wide-ptr #\A)))
    (is (== (make-wide-ptr (tag-value :comm) (wide 1397905034 3832045063 2843405970 3708064556
                                                   1931248981 1080144743 1379707257 644801363))
            (intern-wide-ptr (comm 0 123))))
    (is (== (make-wide-ptr (tag-value :comm) (wide 236359359 1527390219 2343696523 758167213
                                                   871965242 1355972474 190653183 4160106812))
            (intern-wide-ptr (comm 1 123))))
    (is (== (make-wide-ptr (tag-value :comm) (wide 172617292 3084003310 1424146954 835899195
                                                   355959493 4174224837 4227269854 3448899362))
            (intern-wide-ptr (comm 0 '(brass monkey)))))
    (is (== (make-wide-ptr (tag-value :u64) (widen 123)) (intern-wide-ptr 123)))
    (is (== (make-wide-ptr (tag-value :key)
                           (wide 1431751249 3279460643 1685215955 1633314351
                                 299894911 3402633075 3048470820 3631157086))
            (intern-wide-ptr :asparagus)))
    (is (== (make-wide-ptr (tag-value :bignum)
                           (wide #xffffffff #xffffffff #xffffffff #xffffffff
                                 #xffffffff #xffffffff #xffffffff #xffffffff))
            (intern-wide-ptr (1- (expt 2 256)))))
    (is (== (make-wide-ptr (tag-value :bignum)
                           (wide #xfffffffe #xffffffff #xffffffff #xffffffff
                                 #xffffffff #xffffffff #xffffffff #xffffffff))
            ;; check endianness: the first limb should be affected.
            (intern-wide-ptr (- (expt 2 256) 2))))
    (is (== (make-wide-ptr (tag-value :cons)
                           (wide 3601906325 1188897660 3210004168 2644944356
                                 514402910 756461026 1647625721 2397550761))
            (intern-wide-ptr `(foo (bar 1) (:baz #\x "monkey") ,(num 123) ,(1- (expt 2 256))))))
    (let* ((env1 (env 'a 123 nil))
           (env2 (env 'b :xxx env1)))
      (is (== (make-wide-ptr (tag-value :env)
                             (wide 597130475 2448729965 2094617081 3023196126
                                   2451788936 308612520 3598067228 2002918837))
              (intern-wide-ptr env1)))
      (is (== (make-wide-ptr (tag-value :env)
                             (wide 3077842195 572091283 2801462678 1065752347
                                   522695411 544506590 3675411477 2546351666))
              (intern-wide-ptr env2)))
      (is (== (make-wide-ptr (tag-value :thunk)
                             (wide 1398018567 2260761747 719070819 1427893169
                                   225825928 2996049430 2412858216 2883049183))
              (intern-wide-ptr (thunk '(we want the thunk) env2)))))
    (is (== (make-wide-ptr (tag-value :fun)
                           (wide 2071419739 2190085449 200730859 790264635
                                 1557685556 3998478079 4149964193 2656130860))
            (intern-wide-ptr (fun '(a b c) '(+ a (* b c)) nil))))))

(test expr<-wide-ptr
  (let ((*program* (make-program-instance 'test-program)))
    (flet ((test-roundtrip (x)
             (is (== x (expr<-wide-ptr (intern-wide-ptr x))))))
      (test-roundtrip (num 123))
      (test-roundtrip (expt 2 100)) ; bignum
      (test-roundtrip 123456789) ; u64
      (test-roundtrip #\c)
      (test-roundtrip nil)
      (test-roundtrip '(1 . 2))
      (test-roundtrip '(1 2 (3 4)))
      (test-roundtrip 'a)
      (test-roundtrip :mango)
      (let* ((env1 (env 'a 123 nil))
             (env2 (env 'b "xxx" env1)))
        (test-roundtrip env1)
        (test-roundtrip env2)
        (test-roundtrip (thunk '(give up the thunk) env2))
        )
      (test-roundtrip "roundtrip")
      (test-roundtrip (comm 0 123))
      (test-roundtrip (fun '(a b c) '(+ a (* b c)) nil))
      (test-roundtrip 'lurk:lambda))))
